reqStor<- function(sumQin,doy){
fvol<-round(sumQin/1000000, digits=1)
fcol<- as.numeric(fv$col[fv$fv == fvol])
fcs<- as.numeric(fcVol[doy, fcol+2])
#Winter flood control space (low flow years Plate 7-2) ----
if (doy < 91 && fvol > 1.2 && fvol < 1.8){
wcol<- as.numeric(fv$wcol[fv$wfc == fvol])
fcs<- as.numeric(wfc[doy,wcol])
}
if (is.na(fcs) == TRUE){
fcs<- as.numeric(fcVol[doy, fcol+2])
}
#required flood control space (storage volume)
return(fcs)
}
#predict max storage in the next m days
predMaxS<- function(m){
for (day in 1:jul){
volF <- FC$volF[FC$WY == yrs[wy] & FC$doy == day] #todays forecasted inflow
count=0
if (volF >= 0 && day < (jul-m)){
for (it in day:(day+m-1)){
count=count+1
vF = volF - (volF/(jul-day))*(day-it) #predict maxS given equal distribution of inflow
reqS <- reqStor(vF, it)
maxS[day, count] <- (maxAF-reqS) #max storage today given the whole years inflow
}
} else {storD <- 0}
maxS[is.na(maxS)]<- maxAF
}
return(maxS)
}
#determine minimum daily release before April 1
minRelease<- function(day, volF){
ix= which(prj$start <= day & prj$end >= day)
vol1 = volF*prj$b[ix] + prj$c[ix]
if (prj$start[ix] != day){
vol2 = volF*prj$b[ix+1] + prj$c[ix+1]
frac = (day - prj$start[ix])/(prj$end[ix]-prj$start[ix])
volFmar <-  frac*vol1 + (1-frac)*vol2
} else {volFmar = vol1}
volFresid <- volF - volFmar
FCvolAP<- reqStor(volFresid, 91) #flood control space required on april 1
minEvac<- FCvolAP - availStor[day] #minimum evaculation btw today and April 1
minReleaseVol <- minEvac+volFmar
Qmin <- (minReleaseVol*v2f)/(jul-day+1) #associated  qmin
##If statements that constrain for high flows and ramp rates?
}
#determine minimum daily release after April 1
minReleaseApril<-function(day, volF){
ix30 = findInterval(day, prjAP$doy)
ix15=ix30-1
volF_target15 <- volF*prjAP$b[ix15] + prjAP$c[ix15]
volF_target30 <- volF*prjAP$b[ix30] + prjAP$c[ix30]
residual15<- volF-volF_target15
residual30<- volF- volF_target30
if (day < jul-30){
FCvol30<- reqStor(residual30, day+30) #required storage space
minEvac30 <- FCvol30 - availStor[day]
minReleaseVol30 <- minEvac30 + volF_target30
q30<-(minReleaseVol30*v2f)/(jul-day+1)
} else {q30 <- minQ}
if (day < jul-15){
FCvol15<-reqStor(residual15, day+15)
minEvac15 <- FCvol15 - availStor[day]
minReleaseVol15 <- minEvac15 + volF_target15
q15<-(minReleaseVol15*v2f)/(jul-day+1)
} else {q15 <- minQ}
Qmin <- max(q15, q30)
}
#forecast what the storage would be in s days given previous âˆ† in S and make those changes over m days
forecastS<-function(s,m,day){
if (day > s+1){
dsdt= (stor[day] - stor[day-s])/s
storF[day] <<- (dsdt*m)+stor[day]
} else {storF[day]<<- stor[day]}
}
#evaluate change in storage in regard to the forecasted storage to prevent going over maxS
#update discharge, change in storage and day+1 storage
evalS<- function(Qin, day, stor, maxS, Qmin,s,m){
if (storF[day] >= maxS[day,m] && day > s+1){ #&& day <188
dsdtMax= (storF[day] - maxS[day,m])/s
qo[day] <- Qmin[day] + (dsdtMax*v2f)
flag = 'TRUE' #true we need to increase ramp rates to get rid of the water
} else {qo[day] <- Qmin[day]
flag='FALSE'}
if (stor[day] > maxAF){
addQ = (stor[day] - maxAF)*v2f
minFCq[day] <- minFCq[day] + addQ
flag= 'TRUE'
} else {flag='FALSE'}
#if the calculated discharge is greater than +/- 500 set it to +/- 500
if (flag == 'TRUE'){ #going over maxS or maxAF
ramp= 1000
} else {ramp = 500}
if (qo[day] > (qo[day-1] + ramp) && day > 2 ){
qo[day] <- qo[day-1] + ramp
} else if (qo[day] < (qo[day-1]-500) && day > 2 ){
qo[day] <- qo[day-1]-500}
###UPDATE here
#this puts a hard constraints on not topping the dam - but doesnt work 21 times
if (availStor[day] <= (1000*v2f)){
qo[day] <- qo[day] + 1000
availStor[day] <- availStor[day] + 1000*f2v
stor[day] <- stor[day] - (1000*f2v)
}
dS[day] <- (Qin[day]- qo[day])*f2v
#dont let storage go below the minimum
if (stor[day] <= minS){
qo[day] <- minQ
dS[day] <- -minQ*f2v
}
#update storage for the next day
if (day < jul){
stor[day+1]<<-stor[day] + dS[day]  #AF in the reservoir
}
#write out values
qo[day]<<-qo[day]
dS[day]<<-dS[day]
}
#determine change in storage and outflow for a given water year and forecast window
outflowStor<-function(s,m){
results<-list()
discharge<-matrix(data=NA, nrow = jul, ncol=21)
for (wy in 1:21){
#   set up blank matricies
#------------------------------------------
stor<<-matrix(data=NA, nrow = jul, ncol = 1)
maxS<<-matrix(data=NA, nrow = jul, ncol = m)
availStor<<-matrix(data=NA, nrow = jul, ncol = 1)
minFCq<<-matrix(data=NA, nrow = jul, ncol = 1)
storF<<-matrix(data=NA, nrow = jul, ncol = 1)
qo<<-matrix(data=NA, nrow = jul, ncol = 1) #modeled outflow from reservoir
dS<<-matrix(data=NA, nrow = jul, ncol = 1)
#---------
# initalize
#-----
stor[1] <<- FC$AF[doy1[wy]] #initialize with actual storage on Jan 1
Qin<- FC$Q[FC$WY == yrs[wy]]
maxS <<- predMaxS(m) #vector of 198 days of max storage out to M days
#----- run all the functions to get to discharge and updated storage
for (day in 1:jul){
volF<<- FC$volF[FC$WY == yrs[wy] & FC$doy == day] #todays forecasted inflow
availStor[day] <<- maxAF-stor[day]
# Min flood control release for storage goals on April 1 and every 15 days after
if (day < 91){
minFCq[day]<<-minRelease(day, volF)
} else {
minFCq[day]<<-minReleaseApril(day, volF)
}
#minimum discharge is 240
if (minFCq[day] < minQ){
minFCq[day] <<- minQ
}
forecastS(s,m,day)
evalS(Qin, day, stor, maxS, minFCq, s, m)
}
out<- cbind(maxS[,1], storF, stor, minFCq, qo) #availStor dS, only use one arrow or it will overwrite in global env
colnames(out)<-c('maxS','storF', 'stor', 'minQ', 'qo')
results[[wy]]<-out
#discharge[,wy]<-qo
}
#Q<-c(discharge)
return(results)
}
library(pse)
#define probability function - discrete uniform density function for integer parameters
qdunif<-function(p, min, max){
floor(qunif(p, min, max))}
#wrap model
modelRun<-function(params){
return(mapply(outflowStor, params[,1], params[,2]))
}
#set parameters
q.arg<- list(list("min"=1, "max"=14), list("min"=1, "max"=14))
names(q.arg)<-c("s", "m")
factors<-c("s", "m")
#myLHS<-LHS(model=modelRun, factors, N=100, q='qdunif', q.arg, nboot=4)
n=100
#create hypercube
bothLHS <-LHS(model = NULL, factors, N=n, q='qdunif', q.arg, nboot=1)
#bothLHS<-tell(bothLHS, bothLHS$data) #res<-get.results(bothLHS)
outB<-modelRun(bothLHS$data)
outB<-modelRun(bothLHS$data)
#pse plots -- not sure how helpful
#plotscatter(bothLHS,index.res=c(5, 8, 10),  add.lm=FALSE)#stack=TRUE, index.res=c(250, 255, 260)
#plotecdf(bothLHS, stack=TRUE)
#plotprcc(bothLHS, stack=TRUE)
#set only S to change
q.argS<- list(list("min"=1, "max"=14), list("min"=6, "max"=8))
sLHS<-LHS(model = NULL, factors, N=n, q='qdunif', q.argS, nboot=1)
out_S<-modelRun(sLHS$data)
#set only M to change
q.argM<- list(list("min"=6, "max"=8), list("min"=1, "max"=14))
mLHS<-LHS(model = NULL, factors, N=n, q='qdunif', q.argM, nboot=4)
out_M<-modelRun(mLHS$data)
#------------------------------------------------------------------------------------------------
# Re-organize output for analysis - all runs for each wy in one matrix
#------------------------------------------------------------------------------------------------
cleanData<-function(LHSrun){
wy_Q<-lapply(1:21, matrix, data= NA, nrow=196, ncol=n)
wy_stor<-lapply(1:21, matrix, data= NA, nrow=196, ncol=n)
reps = seq(1, length(LHSrun), 21)
count=0
for (i in 1:21){
for (j in 1:n){
wy_Q[[i]][,j]<- LHSrun[[reps[j]+count]][,5]
wy_stor[[i]][,j]<- LHSrun[[reps[j]+count]][,3]
}
count=count+1
}
out<-list(wy_Q, wy_stor)
names(out)<-(c("Q", "stor"))
return(out)
}
both<-cleanData(outB)
sOut<-cleanData(out_S)
mOut<-cleanData(out_M)
pal <- colorRampPalette(c("yellow", "green", "blue"))
cols<-pal(21)
StorSensPlot<-function(LHS, vals, wy, sm, dataOut){
paramVal<-data.matrix(LHS$data[sm])
colRamp<-pal(vals)[as.numeric(cut(paramVal,breaks = vals))]
plt<-matplot(dataOut$stor[[wy]], type='l', col = colRamp)+
ColorLegend(x='topleft', cols = pal(vals), labels=1:vals, cntrlbl=TRUE)+
lines(dataOut$maxS[[wy]][,1], type='l') #max storage
return(plt) ### color coded to m/s values
}
QSensPlot<-function(LHS, vals, wy, sm, dataOut){
paramVal<-data.matrix(LHS$data[sm])
colRamp<-pal(vals)[as.numeric(cut(paramVal,breaks = vals))]
plt<- matplot(dataOut$Q[[wy]], type='l', col = colRamp)+
lines(qlim[,2], type='l', lty=3, col='grey17')
return(plt) ### color coded to m/s values
}
par(mfrow=c(2,2))
wy=17
StorSensPlot(bothLHS, 15, wy, 'm', both)
StorSensPlot(bothLHS, 10, wy, 's', both)
QSensPlot(bothLHS, 15, wy, 'm', both)
QSensPlot(bothLHS, 10, wy, 's', both)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 15, 10, 'm', mOut)
StorSensPlot(sLHS, 10, 10, 's', sOut)
QSensPlot(mLHS, 15, 10, 'm', mOut)
QSensPlot(sLHS, 10, 10, 's', sOut)
install.packages("DescTools")
library("DescTools", lib.loc="~/Library/R/3.5/library")
par(mfrow=c(2,2))
wy=17
StorSensPlot(bothLHS, 15, wy, 'm', both)
StorSensPlot(bothLHS, 10, wy, 's', both)
QSensPlot(bothLHS, 15, wy, 'm', both)
QSensPlot(bothLHS, 10, wy, 's', both)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 15, 10, 'm', mOut)
StorSensPlot(sLHS, 10, 10, 's', sOut)
QSensPlot(mLHS, 15, 10, 'm', mOut)
QSensPlot(sLHS, 10, 10, 's', sOut)
View(q.arg)
par(mfrow=c(2,2))
wy=17
StorSensPlot(bothLHS, 14, wy, 'm', both)
StorSensPlot(bothLHS, 14, wy, 's', both)
QSensPlot(bothLHS, 14, wy, 'm', both)
QSensPlot(bothLHS, 14, wy, 's', both)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(sLHS, 14, wy, 's', sOut)
QSensPlot(mLHS, 14, wy, 'm', mOut)
QSensPlot(sLHS, 14, wy, 's', sOut)
wy=10
StorSensPlot(bothLHS, 14, wy, 'm', both)
StorSensPlot(bothLHS, 14, wy, 's', both)
QSensPlot(bothLHS, 14, wy, 'm', both)
QSensPlot(bothLHS, 14, wy, 's', both)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(sLHS, 14, wy, 's', sOut)
QSensPlot(mLHS, 14, wy, 'm', mOut)
QSensPlot(sLHS, 14, wy, 's', sOut)
par(mfrow=c(2,2))
wy=10
StorSensPlot(bothLHS, 14, wy, 'm', both)
StorSensPlot(bothLHS, 14, wy, 's', both)
QSensPlot(bothLHS, 14, wy, 'm', both)
QSensPlot(bothLHS, 14, wy, 's', both)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(sLHS, 14, wy, 's', sOut)
QSensPlot(mLHS, 14, wy, 'm', mOut)
QSensPlot(sLHS, 14, wy, 's', sOut)
par(mfrow=c(2,2))
wy=10
StorSensPlot(bothLHS, 14, wy, 'm', both)
StorSensPlot(bothLHS, 14, wy, 's', both)
QSensPlot(bothLHS, 14, wy, 'm', both)
QSensPlot(bothLHS, 14, wy, 's', both)
mtext("Model with both variables changing", outer = TRUE, cex = 1.5)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(mLHS, 1, wy, 's', sOut)
QSensPlot(mLHS, 14, wy, 'm', mOut)
QSensPlot(mLHS, 1, wy, 's', sOut)
mtext("Model Variability of M", outer = TRUE, cex = 1.5)
par(mfrow=c(2,2))
StorSensPlot(sLHS, 1, wy, 'm', mOut)
StorSensPlot(sLHS, 14, wy, 's', sOut)
QSensPlot(sLHS, 1, wy, 'm', mOut)
QSensPlot(sLHS, 14, wy, 's', sOut)
mtext("Model Variability of S", outer = TRUE, cex = 1.5)
par(mfrow=c(2,2))
wy=10
StorSensPlot(bothLHS, 14, wy, 'm', both)
StorSensPlot(bothLHS, 14, wy, 's', both)
QSensPlot(bothLHS, 14, wy, 'm', both)
QSensPlot(bothLHS, 14, wy, 's', both)
mtext("Model with both variables changing", outer = TRUE, cex = 1.5)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(mLHS, 3, wy, 's', sOut)
QSensPlot(mLHS, 14, wy, 'm', mOut)
QSensPlot(mLHS, 3, wy, 's', sOut)
mtext("Model Variability of M", outer = TRUE, cex = 1.5)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(mLHS, 3, wy, 's', sOut)
QSensPlot(mLHS, 14, wy, 'm', mOut)
QSensPlot(mLHS, 3, wy, 's', sOut)+
mtext("Model Variability of M", outer = TRUE, cex = 1.5)
par(mfrow=c(2,2))
StorSensPlot(sLHS, 1, wy, 'm', mOut)
StorSensPlot(sLHS, 14, wy, 's', sOut)
QSensPlot(sLHS, 1, wy, 'm', mOut)
QSensPlot(sLHS, 14, wy, 's', sOut)
mtext("Model Variability of S", outer = TRUE, cex = 1.5)
par(mfrow=c(2,2))
wy=10
StorSensPlot(bothLHS, 14, wy, 'm', both)
StorSensPlot(bothLHS, 14, wy, 's', both)
QSensPlot(bothLHS, 14, wy, 'm', both)
QSensPlot(bothLHS, 14, wy, 's', both)
mtext("Model with both variables changing", outer = TRUE, cex = 1.5)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(mLHS, 3, wy, 's', sOut)
QSensPlot(mLHS, 14, wy, 'm', mOut)
QSensPlot(mLHS, 3, wy, 's', sOut)+
par(mfrow=c(2,2))
StorSensPlot(sLHS, 3, wy, 'm', mOut)
StorSensPlot(sLHS, 14, wy, 's', sOut)
QSensPlot(sLHS, 3, wy, 'm', mOut)
QSensPlot(sLHS, 14, wy, 's', sOut)
mtext("Model Variability of S", outer = TRUE, cex = 1.5)
sLHS$data['m']
q.argS<- list(list("min"=1, "max"=14), list("min"=7, "max"=8))
sLHS<-LHS(model = NULL, factors, N=n, q='qdunif', q.argS, nboot=1)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(mLHS, 2, wy, 's', sOut)
QSensPlot(mLHS, 14, wy, 'm', mOut)
QSensPlot(mLHS, 2, wy, 's', sOut)+
par(mfrow=c(2,2))
StorSensPlot(sLHS, 2, wy, 'm', mOut)
StorSensPlot(sLHS, 14, wy, 's', sOut)
QSensPlot(sLHS, 2, wy, 'm', mOut)
QSensPlot(sLHS, 14, wy, 's', sOut)
mtext("Model Variability of S", outer = TRUE, cex = 1.5)
par(mfrow=c(2,2))
wy=10
StorSensPlot(bothLHS, 14, wy, 'm', both)
StorSensPlot(bothLHS, 14, wy, 's', both)
QSensPlot(bothLHS, 14, wy, 'm', both)
QSensPlot(bothLHS, 14, wy, 's', both)
mtext("Model with both variables changing", outer = TRUE, cex = 1.5)
par(mfrow=c(2,2))
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(mLHS, 2, wy, 's', sOut)
QSensPlot(mLHS, 14, wy, 'm', mOut)
QSensPlot(mLHS, 2, wy, 's', sOut)+
par(mfrow=c(2,2))
StorSensPlot(sLHS, 2, wy, 'm', mOut)
StorSensPlot(sLHS, 14, wy, 's', sOut)
QSensPlot(sLHS, 2, wy, 'm', mOut)
QSensPlot(sLHS, 14, wy, 's', sOut)
mtext("Model Variability of S", outer = TRUE, cex = 1.5)
QSensPlot<-function(LHS, vals, wy, sm, dataOut){
paramVal<-data.matrix(LHS$data[sm])
colRamp<-pal(vals)[as.numeric(cut(paramVal,breaks = vals))]
plt<- matplot(dataOut$Q[[wy]], type='l', col = colRamp) +
lines(qlim[,2], type='l', lty=3, col='grey17')
return(plt) ### color coded to m/s values
}
QSensPlot(bothLHS, 14, wy, 'm', both)
OutMeans<-matrix(data=NA, nrow = 196, ncol = 21)
z<-lapply(1:21, matrix, data=NA, nrow = 196, ncol =2)
sd_doy<-matrix(data=NA, nrow = 196, ncol = 21)
for (i in 1:21){
OutMeans[,i]<-rowMeans(wy_Q[[i]], na.rm = FALSE, dims = 1)
z[[i]]<-apply(wy_Q[[i]], 1, quantile, probs = c(0.05, 0.95),  na.rm = TRUE)
sd_doy[,i]<- apply(wy_Q[[i]], 1, sd)
}
matplot(both$Q[[wy]], type='l')
matplot(both$stor[[wy]], type='l')
matplot(sOut$stor[[wy]], type='l')
par(mfrow=c(1,3))
matplot(both$stor[[wy]], type='l')
matplot(sOut$stor[[wy]], type='l')
matplot(mOut$stor[[wy]], type='l')
par(mfrow=c(3,1))
matplot(both$stor[[wy]], type='l')
matplot(sOut$stor[[wy]], type='l')
matplot(mOut$stor[[wy]], type='l')
par(mfrow=c(4,1))
QSensPlot(bothLHS, 14, wy, 'm', both)
QSensPlot(bothLHS, 14, wy, 's', both)
QSensPlot(mLHS, 14, wy, 'm', mOut)
QSensPlot(sLHS, 14, wy, 's', sOut)
par(mfrow=c(4,1))
StorSensPlot(bothLHS, 14, wy, 'm', both)
StorSensPlot(bothLHS, 14, wy, 's', both)
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(sLHS, 14, wy, 's', sOut)
for (wy in 1:21){
par(mfrow=c(4,1))
StorSensPlot(bothLHS, 14, wy, 'm', both)
StorSensPlot(bothLHS, 14, wy, 's', both)
StorSensPlot(mLHS, 14, wy, 'm', mOut)
StorSensPlot(sLHS, 14, wy, 's', sOut)
}
View(out_S)
View(both)
Qstats<-function(dataOut){
OutMeans<-matrix(data=NA, nrow = 196, ncol = 21)
z<-lapply(1:21, matrix, data=NA, nrow = 196, ncol =2)
sd_doy<-matrix(data=NA, nrow = 196, ncol = 21)
for (i in 1:21){
wy_Q<-dataOut$Q[[i]]
OutMeans[,i]<-rowMeans(wy_Q, na.rm = FALSE, dims = 1)
z[[i]]<-apply(wy_Q, 1, quantile, probs = c(0.05, 0.95),  na.rm = TRUE)
sd_doy[,i]<- apply(wy_Q, 1, sd)
}
out<-list(OutMeans, z, sd_doy)
names(out)<-c('mean', 'ci', 'sd')
}
bothQstats<-Qstats(both)
OutMeans<-matrix(data=NA, nrow = 196, ncol = 21)
z<-lapply(1:21, matrix, data=NA, nrow = 196, ncol =2)
sd_doy<-matrix(data=NA, nrow = 196, ncol = 21)
dataOut=btoh
dataOut=both
View(dataOut)
for (i in 1:21){
wy_Q<-dataOut$Q[[i]]
OutMeans[,i]<-rowMeans(wy_Q, na.rm = FALSE, dims = 1)
z[[i]]<-apply(wy_Q, 1, quantile, probs = c(0.05, 0.95),  na.rm = TRUE)
sd_doy[,i]<- apply(wy_Q, 1, sd)
}
View(OutMeans)
View(z)
View(sd_doy)
out<-list(OutMeans, z, sd_doy)
View(out)
Qstats<-function(dataOut){
OutMeans<-matrix(data=NA, nrow = 196, ncol = 21)
z<-lapply(1:21, matrix, data=NA, nrow = 196, ncol =2)
sd_doy<-matrix(data=NA, nrow = 196, ncol = 21)
for (i in 1:21){
wy_Q<-dataOut$Q[[i]]
OutMeans[,i]<-rowMeans(wy_Q, na.rm = FALSE, dims = 1)
z[[i]]<-apply(wy_Q, 1, quantile, probs = c(0.05, 0.95),  na.rm = TRUE)
sd_doy[,i]<- apply(wy_Q, 1, sd)
}
out<-list(OutMeans, z, sd_doy)
names(out)<-c('mean', 'ci', 'sd')
return(out)
}
bothQstats<-Qstats(both)
View(bothQstats)
matplot(bothQstats$sd, type='l')
bothQstats<-Qstats(both)
sQstats<-Qstats(sOut)
mQstats<-Qstats(mOut)
matplot(mQstats$sd, type='l')
matplot(sQstats$sd, type='l')
storstats<-function(dataOut){
OutMeans<-matrix(data=NA, nrow = 196, ncol = 21)
z<-lapply(1:21, matrix, data=NA, nrow = 196, ncol =2)
sd_doy<-matrix(data=NA, nrow = 196, ncol = 21)
for (i in 1:21){
wy_Q<-dataOut$stor[[i]]
OutMeans[,i]<-rowMeans(wy_Q, na.rm = FALSE, dims = 1)
z[[i]]<-apply(wy_Q, 1, quantile, probs = c(0.05, 0.95),  na.rm = TRUE)
sd_doy[,i]<- apply(wy_Q, 1, sd)
}
out<-list(OutMeans, z, sd_doy)
names(out)<-c('mean', 'ci', 'sd')
return(out)
}
matplot(bothSstats$sd, type='l')
matplot(mSstats$sd, type='l')
matplot(sSstats$sd, type='l')
bothSstats<-storstats(both)
sSstats<-storstats(sOut)
mSstats<-storstats(mOut)
matplot(bothSstats$sd, type='l')
matplot(mSstats$sd, type='l')
matplot(sSstats$sd, type='l')
max(bothSstats$sd)
matplot(bothSstats$sd, type='l', ylim=c(0,84000))
matplot(mSstats$sd, type='l', ylim=c(0,84000))
matplot(sSstats$sd, type='l', ylim=c(0,84000))
