qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
}
day =30
qo$30
qo[30]
qo[28:35]
day >10 && qo[day] > (qo[day-1] + 500)
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
dD
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
ramprate <- function(qo, stor){
for (day in 1:jul){
if (day > 10 && qo[day] < (qo[day-1] - 500)){ #todays qo < 500cfs than yesterdays
Q=qo[day]
qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
}
}
outlist<-(list("dS"=dS, "qo"=qo, "stor"=stor))
return(outlist)
}
#-------------------------------------------------------------
#   set up blank matricies
#------------------------------------------------------------
resS=matrix(data=NA, nrow = jul, ncol = 1)
stor=matrix(data=NA, nrow = jul, ncol = 1)
maxS=matrix(data=NA, nrow = jul, ncol = 1)
dS=matrix(data=NA, nrow = jul, ncol = 1)
minFCq=matrix(data=NA, nrow = jul, ncol = 1)
qo=matrix(data=NA, nrow = jul, ncol = 1)
#---------------------------------------------------------------
#   determine change in storage and outflow for any day of year
#---------------------------------------------------------------
#select Qin from matrix or array? - turn into funtion
wy =1
stor[1]<-FC$AF[doy1[wy]] #initialize with actual storage on Jan 1
Qin<- FC$Q[FC$WY == yrs[wy]]
for (day in 1:jul){
volF= FC$volF[FC$WY == yrs[wy] & FC$doy == day] #todays forecasted inflow
if (volF >= 0){
maxSday<- resStor(volF, day)
storD<-maxSday$stor
} else {storD <- 0}
maxS[day] <- maxAF-storD #max storage today given the whole years inflow
#Determine Qmin
if (day < 91){
minFCq[day]<-minRelease()
} else {
minFCq[day]<-minReleaseApril()
}
#minimum discharge is 240
if (minFCq[day] <= minQ){
minFCq[day] <- minQ
}
resS <- changeS(Qin, day, stor, maxS[day], minFCq[day])
qo[day]<-resS$qo[day]
dS[day]<- resS$dS[day]
if (day < jul){
stor[day+1]<-resS$stor[day+1] #AF in the reservoir
}
}
for (day in 1:jul){
rr=ramprate(qo, stor)
}
day > 10 && qo[day] < (qo[day-1] - 500)
#Ramping rate is +/- 500 cfs per day  --> distributes the water over following days
ramprate <- function(qo, stor){
for (day in 1:jul){
if (day > 10 && qo[day] < (qo[day-1] - 500)){ #todays qo < 500cfs than yesterdays
Q=qo[day]
qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else{qo[day]<-qo[day]}
}
outlist<-(list("dS"=dS, "qo"=qo, "stor"=stor))
return(outlist)
}
stor[1]<-FC$AF[doy1[wy]] #initialize with actual storage on Jan 1
Qin<- FC$Q[FC$WY == yrs[wy]]
for (day in 1:jul){
volF= FC$volF[FC$WY == yrs[wy] & FC$doy == day] #todays forecasted inflow
if (volF >= 0){
maxSday<- resStor(volF, day)
storD<-maxSday$stor
} else {storD <- 0}
maxS[day] <- maxAF-storD #max storage today given the whole years inflow
#Determine Qmin
if (day < 91){
minFCq[day]<-minRelease()
} else {
minFCq[day]<-minReleaseApril()
}
#minimum discharge is 240
if (minFCq[day] <= minQ){
minFCq[day] <- minQ
}
resS <- changeS(Qin, day, stor, maxS[day], minFCq[day])
qo[day]<-resS$qo[day]
dS[day]<- resS$dS[day]
if (day < jul){
stor[day+1]<-resS$stor[day+1] #AF in the reservoir
}
}
for (day in 1:jul){
rr=ramprate(qo, stor)
}
if (day > 10 && qo[day] < (qo[day-1] - 500)){ #todays qo < 500cfs than yesterdays
Q=qo[day]
qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
}else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else{qo[day]<-qo[day]}
day = 2
if (day > 10 && qo[day] < (qo[day-1] - 500)){ #todays qo < 500cfs than yesterdays
Q=qo[day]
qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
}else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else{qo[day]<-qo[day]}
(day > 10 && qo[day] < (qo[day-1] - 500))
(day >10 && qo[day] > (qo[day-1] + 500))
qo[day]<-qo[day
for (day in 1:jul){
if (day > 10 && qo[day] < (qo[day-1] - 500)){ #todays qo < 500cfs than yesterdays
Q=qo[day]
qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
}else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else{qo[day]<-qo[day]}
}
for (day in 1:jul){
if (day > 10 && qo[day] < (qo[day-1] - 500)){ #todays qo < 500cfs than yesterdays
Q=qo[day]
qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
}else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else{qo[day]<-qo[day]}
}
dD
round((Qd)/500)
Qd/(round((Qd)/500))
Q=qo[day]
#Ramping rate is +/- 500 cfs per day  --> distributes the water over following days
ramprate <- function(qo, stor){
for (day in 1:jul){
if (day > 10 && qo[day] < (qo[day-1] - 500)){ #todays qo < 500cfs than yesterdays
Q=qo[day]
qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
}else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else{qo[day]<-qo[day]}
}
outlist<-(list("dS"=dS, "qo"=qo, "stor"=stor))
return(outlist)
}
resS=matrix(data=NA, nrow = jul, ncol = 1)
stor=matrix(data=NA, nrow = jul, ncol = 1)
maxS=matrix(data=NA, nrow = jul, ncol = 1)
dS=matrix(data=NA, nrow = jul, ncol = 1)
minFCq=matrix(data=NA, nrow = jul, ncol = 1)
qo=matrix(data=NA, nrow = jul, ncol = 1)
stor[1]<-FC$AF[doy1[wy]] #initialize with actual storage on Jan 1
Qin<- FC$Q[FC$WY == yrs[wy]]
for (day in 1:jul){
volF= FC$volF[FC$WY == yrs[wy] & FC$doy == day] #todays forecasted inflow
if (volF >= 0){
maxSday<- resStor(volF, day)
storD<-maxSday$stor
} else {storD <- 0}
maxS[day] <- maxAF-storD #max storage today given the whole years inflow
#Determine Qmin
if (day < 91){
minFCq[day]<-minRelease()
} else {
minFCq[day]<-minReleaseApril()
}
#minimum discharge is 240
if (minFCq[day] <= minQ){
minFCq[day] <- minQ
}
resS <- changeS(Qin, day, stor, maxS[day], minFCq[day])
qo[day]<-resS$qo[day]
dS[day]<- resS$dS[day]
if (day < jul){
stor[day+1]<-resS$stor[day+1] #AF in the reservoir
}
}
day = 30
day >10 && qo[day] > (qo[day-1] + 500)
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
Qd
dD
Qd/(round((Qd)/500))
(day+1):dD
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else{qo[day]<-qo[day]}
day
if (day > 10 && qo[day] < (qo[day-1] - 500)){ #todays qo < 500cfs than yesterdays
Q=qo[day]
qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
}else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else{qo[day]<-qo[day]}
qo[day] > (qo[day-1] + 500)
qo[day]
day
resS=matrix(data=NA, nrow = jul, ncol = 1)
stor=matrix(data=NA, nrow = jul, ncol = 1)
maxS=matrix(data=NA, nrow = jul, ncol = 1)
dS=matrix(data=NA, nrow = jul, ncol = 1)
minFCq=matrix(data=NA, nrow = jul, ncol = 1)
qo=matrix(data=NA, nrow = jul, ncol = 1)
stor[1]<-FC$AF[doy1[wy]] #initialize with actual storage on Jan 1
Qin<- FC$Q[FC$WY == yrs[wy]]
for (day in 1:jul){
volF= FC$volF[FC$WY == yrs[wy] & FC$doy == day] #todays forecasted inflow
if (volF >= 0){
maxSday<- resStor(volF, day)
storD<-maxSday$stor
} else {storD <- 0}
maxS[day] <- maxAF-storD #max storage today given the whole years inflow
#Determine Qmin
if (day < 91){
minFCq[day]<-minRelease()
} else {
minFCq[day]<-minReleaseApril()
}
#minimum discharge is 240
if (minFCq[day] <= minQ){
minFCq[day] <- minQ
}
resS <- changeS(Qin, day, stor, maxS[day], minFCq[day])
qo[day]<-resS$qo[day]
dS[day]<- resS$dS[day]
if (day < jul){
stor[day+1]<-resS$stor[day+1] #AF in the reservoir
}
}
day=30
qo[day]
(day >10 && qo[day] > (qo[day-1] + 500))
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
qo[29:35]
#Ramping rate is +/- 500 cfs per day  --> distributes the water over following days
ramprate <- function(qo, stor){
for (day in 1:jul){
if (day > 10 && qo[day] < (qo[day-1] - 500)){ #todays qo < 500cfs than yesterdays
Q=qo[day]
qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
}else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else{qo[day]<-qo[day]}
}
outlist<-(list("dS"=dS, "qo"=qo, "stor"=stor))
return(outlist)
}
#-------------------------------------------------------------
#   set up blank matricies
#------------------------------------------------------------
resS=matrix(data=NA, nrow = jul, ncol = 1)
stor=matrix(data=NA, nrow = jul, ncol = 1)
maxS=matrix(data=NA, nrow = jul, ncol = 1)
dS=matrix(data=NA, nrow = jul, ncol = 1)
minFCq=matrix(data=NA, nrow = jul, ncol = 1)
qo=matrix(data=NA, nrow = jul, ncol = 1)
stor[1]<-FC$AF[doy1[wy]] #initialize with actual storage on Jan 1
Qin<- FC$Q[FC$WY == yrs[wy]]
for (day in 1:jul){
volF= FC$volF[FC$WY == yrs[wy] & FC$doy == day] #todays forecasted inflow
if (volF >= 0){
maxSday<- resStor(volF, day)
storD<-maxSday$stor
} else {storD <- 0}
maxS[day] <- maxAF-storD #max storage today given the whole years inflow
#Determine Qmin
if (day < 91){
minFCq[day]<-minRelease()
} else {
minFCq[day]<-minReleaseApril()
}
#minimum discharge is 240
if (minFCq[day] <= minQ){
minFCq[day] <- minQ
}
resS <- changeS(Qin, day, stor, maxS[day], minFCq[day])
qo[day]<-resS$qo[day]
dS[day]<- resS$dS[day]
if (day < jul){
stor[day+1]<-resS$stor[day+1] #AF in the reservoir
}
}
for (day in 1:jul){
if (day > 10 && qo[day] < (qo[day-1] - 500)){ #todays qo < 500cfs than yesterdays
Q=qo[day]
qo[day] <- qo[day-1]-500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
}else if (day >10 && qo[day] > (qo[day-1] + 500)){
#todays qo > 500cfs than yesterday
Q=qo[day]
qo[day] <- qo[day-1]+500
dS[day] <- Qin[day]- (qo[day]*f2v)
Qd<-Q-qo[day]
dD <- day + round((Qd)/500)
if (dD > jul) {dD=jul}
qo[(day+1):dD] <- qo[(day+1):dD]+ Qd/(round((Qd)/500))
dS[(day+1):dD] <- (Qin[(day+1):dD]-qo[(day+1):dD])*f2v
stor[day:dD] <- stor[day:dD] + dS[day:dD]
} else{qo[day]<-qo[day]}
}
day
qo[38]
